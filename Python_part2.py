''' 
Блок 2: Python
Задание 1: Изоморфизмы
Реализовать функцию (или тело функции), которая проверяет на изоморфность два слова. Пояснение: строки s и t называются изоморфными, если все вхождения каждого символа строки s можно последовательно заменить другим символом и получить строку t. Порядок символов при этом должен сохраняться, а замена — быть уникальной. Так, два разных символа строки s нельзя заменить одним и тем же символом из строки t, а вот одинаковые символы в строке s должны заменяться одним и тем же символом.
# Пример:
s = 'paper' 
t = 'title' 
print(is_isomorphic(s, t))
# Вывод: 
True
Оценить оптимальность решения по времени и памяти и прикрепить текст кода'''

def is_isomorphic(s, t):
    if len(s) != len(t):
        return False

    mapping_s_t = {}  
    mapped_t = set()  

    for cs, ct in zip(s, t):
        if cs in mapping_s_t:
            if mapping_s_t[cs] != ct:
                return False  
        else:
            if ct in mapped_t:
                return False  
            mapping_s_t[cs] = ct
            mapped_t.add(ct)

    return True




'''Задание 2: Натуральная последовательность
Реализовать функцию (или тело функции), которая находит единственное отсутствующее число из последовательности натуральных чисел 1,2,…,n.
# Пример:
nums = [1, 2, 3, 4, 5, 6, 8, 9, 10, 11]
print(missing_number(nums))
# Вывод: 
7
Оценить оптимальность решения по времени и памяти и прикрепить текст кода.'''


def missing_number(nums):
    n = len(nums) + 1  
    sum_expected = n * (n + 1) // 2
    sum_actual = sum(nums)
    return sum_expected - sum_actual




'''Задание 3: Факторизация
Реализовать функцию (или тело функции), которая при введении натурального числа n разбивает его на простые множители (представить его в виде простых чисел).
# Пример:
n = 56
print(prime_factors(n))
# Вывод:
[2, 2, 2, 7]
Оценить оптимальность решения по времени и памяти и прикрепить текст кода.'''

def prime_factors(n):
    factors = []


    while n % 2 == 0:
        factors.append(2)
        n //= 2

    i = 3
    while i * i <= n:
        while n % i == 0:
            factors.append(i)
            n //= i
        i += 2

    if n > 1:
        factors.append(n)

    return factors


